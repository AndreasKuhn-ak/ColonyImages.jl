<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ColonyImages.jl</title><meta name="title" content="Home · ColonyImages.jl"/><meta property="og:title" content="Home · ColonyImages.jl"/><meta property="twitter:title" content="Home · ColonyImages.jl"/><meta name="description" content="Documentation for ColonyImages.jl."/><meta property="og:description" content="Documentation for ColonyImages.jl."/><meta property="twitter:description" content="Documentation for ColonyImages.jl."/><meta property="og:url" content="https://AndreasKuhn-ak.github.io/ColonyImages.jl/"/><meta property="twitter:url" content="https://AndreasKuhn-ak.github.io/ColonyImages.jl/"/><link rel="canonical" href="https://AndreasKuhn-ak.github.io/ColonyImages.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ColonyImages.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/master/docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ColonyImages"><a class="docs-heading-anchor" href="#ColonyImages">ColonyImages</a><a id="ColonyImages-1"></a><a class="docs-heading-anchor-permalink" href="#ColonyImages" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/AndreasKuhn-ak/ColonyImages.jl">ColonyImages</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.analysis_parameters" href="#ColonyImages.analysis_parameters"><code>ColonyImages.analysis_parameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">analysis_parameters</code></pre><p>A struct for holding parameters related to the analysis.</p><p><strong>Fields</strong></p><ul><li><code>plot_theme::Attributes</code>: An Attributes object for setting the theme of the plots. Default is a Theme object with a fontsize of 25, a size of (1000,800), a markersize of 15 for Scatter plots, and a linewidth of 4 for Lines plots.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">params = analysis_parameters()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/parameters.jl#L57-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.parameters" href="#ColonyImages.parameters"><code>ColonyImages.parameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">parameters</code></pre><p>A struct that holds various parameters for colony image processing, creation and analysis.</p><p><strong>Fields</strong></p><ul><li><code>time_points::Vector{Float64}</code>: The time points for the analysis. Default is <code>[0,48,96,144]</code>.</li><li><code>threshold_conv::Float64</code>: The threshold for the convolution. Default is <code>0.8</code>.</li><li><code>threshold_c::Float64</code>: Another threshold parameter. Default is <code>0.8</code>.</li><li><code>kernel_ratio::Float64</code>: The ratio for the kernel. Default is <code>0.4</code>.</li><li><code>steps_angular::Int</code>: The number of angular steps. Default is <code>360</code>.</li><li><code>samples_pair::Int</code>: The number of sample pairs. Default is <code>2000000</code>.</li><li><code>timesteps::Int64</code>: The number of time steps. Default is <code>300</code>.</li><li><code>im_size::Vector{Int}</code>: The size of the image. Default is <code>[600,600]</code>.</li><li><code>stacks::Int</code>: The number of stacks, which is the length of <code>time_points</code>.</li><li><code>radius_colony::Int</code>: The radius of the colony. Default is <code>round(Int,(im_size[1]*0.05))</code>.</li><li><code>Center::Vector{Int}</code>: The center of the image. Default is <code>round.(Int,im_size./2)</code>.</li><li><code>growth_rate::Float64</code>: The growth rate of the colony. Default is <code>0.02971700864000873</code>.</li><li><code>colony_size::Function</code>: A function to calculate the size of the colony. Default is <code>t-&gt; (1+growth_rate).^t</code>.</li><li><code>relative_size_filles_holes::Float64</code>: The relative size of filled holes. Default is <code>0.01</code>.</li><li><code>laplac_kernel::Matrix{Int}</code>: The Laplacian kernel. Default is <code>[0 1 0; 1 -4 1; 0 1 0]</code>.</li><li><code>colony_nr::Int</code>: The number of colonies. Default is <code>4</code>.</li><li><code>colonies::Vector{String}</code>: The names of the colonies. Default is <code>[&quot;Colony x artifical&quot; for x in 1:colony_nr]</code>.</li><li><code>plot_factor::AbstractFloat</code>: The factor for plotting. Default is <code>2.0</code>.</li><li><code>Points::Vector{Vector{Vector{Int}}}</code>: The lattice points. Default is <code>lattice_points(Int(maximum(im_size)÷2))</code>.</li><li><code>col_size_add::Vector{Float64}</code>: The additional size of the colony. Default is <code>colony_size.(time_points).-1</code>.</li><li><code>col_size_add_diff::Vector{Float64}</code>: The difference in the additional size of the colony. Default is <code>col_size_add[2:end]-col_size_add[1:end-1]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/parameters.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.angular_metric-Tuple{Union{BitMatrix, Matrix{&lt;:Real}}, Vector{Int64}}" href="#ColonyImages.angular_metric-Tuple{Union{BitMatrix, Matrix{&lt;:Real}}, Vector{Int64}}"><code>ColonyImages.angular_metric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angular_metric(img::Union{Matrix{&lt;:Real}, BitMatrix}, center::Vector{Int}; steps::Int = 360)</code></pre><p>Calculates an angular metric for a given image. The metric is a vector where each element represents the number of pixels in a certain angular sector of the image.  The sectors are determined by dividing a circle centered at a given point into a certain number of equal parts.</p><p><strong>Arguments</strong></p><ul><li><code>img::Union{Matrix{&lt;:Real}, BitMatrix}</code>: The input image.</li><li><code>center::Vector{Int}</code>: The center of the circle.</li><li><code>steps::Int</code>: The number of sectors into which the circle is divided. Default is 360.</li></ul><p><strong>Returns</strong></p><ul><li>A vector where each element represents the number of pixels in a certain angular sector of the image.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/image_functions.jl#L407-L421">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.approx_radi_colo-Tuple{Union{BitMatrix, Matrix{&lt;:Real}}}" href="#ColonyImages.approx_radi_colo-Tuple{Union{BitMatrix, Matrix{&lt;:Real}}}"><code>ColonyImages.approx_radi_colo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">approx_radi_colo(img::Union{Matrix{&lt;:Real}, BitMatrix})</code></pre><p>Calculates the approximate diameter of a colony by summing up all the pixel values and taking the square root of the sum.</p><p>This function assumes that the pixel values represent the area of the colony. The diameter is then approximated using the formula for the diameter of a circle given its area.</p><p><strong>Arguments</strong></p><ul><li><code>img::Union{Matrix{&lt;:Real}, BitMatrix}</code>: A 2D array representing the image. The pixel values are assumed to represent the area of the colony.</li></ul><p><strong>Returns</strong></p><ul><li>A float representing the approximate diameter of the colony.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/image_functions.jl#L134-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.b_w-Tuple{Any}" href="#ColonyImages.b_w-Tuple{Any}"><code>ColonyImages.b_w</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">b_w(img)</code></pre><p>Converts a grayscale colony image into a binary image/BitArray. If more than half of the image is black, it inverts the image.  This ensures that in the output image, the pixels inside the colony are always set to 1 and the background pixels to 0,  regardless of the inversion status of the input image.</p><p><strong>Arguments</strong></p><ul><li><code>img</code>: The input image.</li></ul><p><strong>Returns</strong></p><ul><li>A binary image where the colony pixels are set to 1 and the background pixels are set to 0.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/image_functions.jl#L295-L308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.build_artifical_colony!-Tuple{Vector{Int64}, AbstractArray, Int64, Vector{Vector{Vector{Int64}}}}" href="#ColonyImages.build_artifical_colony!-Tuple{Vector{Int64}, AbstractArray, Int64, Vector{Vector{Vector{Int64}}}}"><code>ColonyImages.build_artifical_colony!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_artifical_colony!(center::Vector{Int}, img::AbstractArray}, radius::Int, points::Vector{Vector{Vector{Int}}})</code></pre><p>This function constructs an artificial spherical colony within a given image. The colony is represented as a circle with a specified center and radius.  The function directly modifies the input image.</p><p><strong>Arguments</strong></p><ul><li><code>center::Vector{Int}</code>: A vector representing the center coordinates of the colony.</li><li><code>img::AbstractArray</code>: The input image where the colony will be built.</li><li><code>radius::Int</code>: The radius of the colony.</li><li><code>points::Vector{Vector{Vector{Int}}}</code>: A nested vector containing the points used to construct the colony.</li></ul><p><strong>Returns</strong></p><ul><li>The image with the built colony.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/artifical_colony_creation.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.build_circle-Tuple{Vector{Int64}, Union{BitMatrix, Matrix{&lt;:Real}}, Vector{Vector{Vector{Int64}}}}" href="#ColonyImages.build_circle-Tuple{Vector{Int64}, Union{BitMatrix, Matrix{&lt;:Real}}, Vector{Vector{Vector{Int64}}}}"><code>ColonyImages.build_circle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_circle(center::Vector{Int}, img::Union{Matrix{&lt;:Real}, BitMatrix}, points::Vector{Vector{Vector{Int}}}; threshold = 0.8::Float64)</code></pre><p>Creates a binary image with the same size as the input image. The binary image is a circle with a given center.  The circle is built by iterating over a set of points and setting the corresponding pixel in the binary image to 1 if the point is within the circle. The occupation in the outermost circle band is calculated in each iteration and stored in the occupation vector.  The function stops building the circle when the mean of the occupation vector is less than a given threshold.</p><p><strong>Arguments</strong></p><ul><li><code>center::Vector{Int}</code>: The center of the circle.</li><li><code>img::Union{Matrix{&lt;:Real}, BitMatrix}</code>: The input image.</li><li><code>points::Vector{Vector{Vector{Int}}}</code>: A set of points used to build the circle.</li><li><code>threshold::Float64</code>: The threshold for the mean of the occupation vector. Defaults to 0.8.</li></ul><p><strong>Returns</strong></p><ul><li><code>circle_kernel</code>: A binary image representing the circle.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/image_functions.jl#L186-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.centroid-Tuple{Union{BitMatrix, Matrix{&lt;:Real}}}" href="#ColonyImages.centroid-Tuple{Union{BitMatrix, Matrix{&lt;:Real}}}"><code>ColonyImages.centroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid(img::Union{Matrix{&lt;:Real}, BitMatrix})</code></pre><p>Calculates the centroid of a given image <code>img</code>.</p><p>The centroid is calculated as the average of the x and y coordinates of all non-zero pixels in the image,  weighted by their intensity. The coordinates are then rounded to the nearest integer.</p><p><strong>Arguments</strong></p><ul><li><code>img::Union{Matrix{&lt;:Real}, BitMatrix}</code>: A 2D array representing the image. Non-zero values are considered as part of the object to find the centroid of.</li></ul><p><strong>Returns</strong></p><ul><li><code>centroid_norm::Vector{Int64}</code>: A vector containing the x and y coordinates of the centroid.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/image_functions.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.conv-Tuple{AbstractArray, AbstractArray}" href="#ColonyImages.conv-Tuple{AbstractArray, AbstractArray}"><code>ColonyImages.conv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conv(img::Union{Matrix{&lt;:Real}, BitMatrix}, kernel::Union{Matrix{&lt;:Real}, BitMatrix})</code></pre><p>Performs a convolution operation on an image using a given kernel. The input image and kernel are 2D arrays of Int or Float or Bool.  The function returns a 2D Float64 array of the same size as the input image.</p><p><strong>Arguments</strong></p><ul><li><code>img::Union{Matrix{&lt;:Real}, BitMatrix}</code>: The input image, a 2D array of Int, Float or Bool.</li><li><code>kernel::Union{Matrix{&lt;:Real}, BitMatrix}</code>: The kernel used for the convolution, a smaller 2D array of Int,Float or Bool.</li></ul><p><strong>Returns</strong></p><ul><li>A 2D Float64 array representing the convolved image.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/image_functions.jl#L244-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.create_kernel-Tuple{Int64}" href="#ColonyImages.create_kernel-Tuple{Int64}"><code>ColonyImages.create_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_kernel(rad::Int;  geometry::String = &quot;circle&quot;)</code></pre><p>Creates a binary image kernel with a given radius. The kernel can be either a circle or a square.</p><p><strong>Arguments</strong></p><ul><li><code>rad::Int</code>: The radius of the kernel.</li><li><code>geometry::String</code>: The shape of the kernel. Can be either &quot;circle&quot; or &quot;square&quot;. Defaults to &quot;circle&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>kernel</code>: A 2D array representing the kernel.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/image_functions.jl#L154-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.expand_colony_circular!-Tuple{AbstractArray, Vector{Vector{Vector{Int64}}}, Vector{Int64}, Int64}" href="#ColonyImages.expand_colony_circular!-Tuple{AbstractArray, Vector{Vector{Vector{Int64}}}, Vector{Int64}, Int64}"><code>ColonyImages.expand_colony_circular!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expand_colony_circular!(img::AbstractArray, points::Vector{Vector{Vector{Int}}}, center::Vector{Int}, pixels_to_add::Int)</code></pre><p>This function expands an artifical colony in a circular pattern within an image. The expansion starts from the center of the colony and proceeds outward.  The function directly modifies the input image.</p><p><strong>Arguments</strong></p><ul><li><code>img::AbstractArray</code>: The input image where the colony will be expanded.</li><li><code>points::Vector{Vector{Vector{Int}}}</code>: A nested vector containing the points used to expand the colony.</li><li><code>center::Vector{Int}</code>: A vector representing the center coordinates of the colony.</li><li><code>pixels_to_add::Int</code>: The number of pixels to add to the colony.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/artifical_colony_creation.jl#L47-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.expand_colony_finger_radom_cov!-Tuple{AbstractArray, Int64, Any}" href="#ColonyImages.expand_colony_finger_radom_cov!-Tuple{AbstractArray, Int64, Any}"><code>ColonyImages.expand_colony_finger_radom_cov!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expand_colony_finger_radom_cov!(img::AbstractArray, pixels_to_add::Int, dir::Vector{Int}; dir_match_rate::AbstractFloat = 0.999, still_spawn_rate::AbstractFloat = 0.99, min_neigbour::Int = 2)</code></pre><p>Expand the colony in the image <code>img</code> by adding <code>pixels_to_add</code> pixels. The expansion is done randomly  at the border of the colony, but it is more likely to expand in the direction specified by <code>dir</code>.  The border is determined by convolving the image with a Laplacian kernel and finding points where the convolution  is greater than 0.1. The function modifies the input image in-place.</p><p><strong>Arguments</strong></p><ul><li><code>img::AbstractArray</code>: A 2D array representing the image of the colony. The colony is represented by 1s and the background by 0s.</li><li><code>pixels_to_add::Int</code>: The number of pixels to add to the colony.</li><li><code>dir::Vector{Int}</code>: A vector representing the preferred direction of expansion.</li><li><code>dir_match_rate::AbstractFloat</code>: A float representing the threshold for the dot product between the preferred direction and the point. Default is 0.999.</li><li><code>still_spawn_rate::AbstractFloat</code>: A float representing the probability of expanding in a direction opposite to <code>dir</code>. Default is 0.99.</li><li><code>min_neigbour::Int</code>: The minimum number of neighboring points that must be occupied for a point to be added to the colony. Default is 2.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">img = zeros(100, 100)
img[50:55, 50:55] .= 1
expand_colony_finger_radom_cov!(img, 100, [1, 0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/artifical_colony_creation.jl#L464-L486">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.expand_colony_fractal_radom_cov!-Tuple{AbstractArray, Int64}" href="#ColonyImages.expand_colony_fractal_radom_cov!-Tuple{AbstractArray, Int64}"><code>ColonyImages.expand_colony_fractal_radom_cov!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expand_colony_fractal_radom_cov!(img::AbstractArray, pixels_to_add::Int; max_neigbours::Int, = 1 prob_neigbour::AbstractFloat = 0.3)</code></pre><p>Expand the colony in the image <code>img</code> by adding <code>pixels_to_add</code> pixels. The expansion is done randomly  at the border of the colony, but it is more likely to expand to points that only have <code>max_neigbours</code> or less.  The border is determined by convolving the image with a Laplacian kernel and finding points where the convolution  is greater than 0.1. The function modifies the input image in-place.</p><p><strong>Arguments</strong></p><ul><li><code>img::AbstractArray</code>: A 2D array of type Matrix with elements of any subtype of Real or a BitMatrix, representing the image of the colony. The colony is represented by 1s and the background by 0s.</li><li><code>pixels_to_add::Int</code>: An integer representing the number of pixels to add to the colony.</li><li><code>max_neigbours</code>: An integer representing the maximum number of neighbours a point can have to be considered for expansion. Default is 1.</li><li><code>prob_neigbour::AbstractFloat</code>: A float representing the probability of expanding to a point with more than <code>max_neigbours</code>. Default is 0.3.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">img = zeros(100, 100)
img[50:55, 50:55] .= 1
expand_colony_fractal_radom_cov!(img, 100)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/artifical_colony_creation.jl#L300-L320">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.expand_colony_point!-Tuple{AbstractArray, AbstractArray, CartesianIndex{2}}" href="#ColonyImages.expand_colony_point!-Tuple{AbstractArray, AbstractArray, CartesianIndex{2}}"><code>ColonyImages.expand_colony_point!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expand_colony_point!(img::AbstractArray, cov_img::AbstractArray, point::Vector{Int})</code></pre><p>Expands a colony at a given point in an image. The function uses a Laplacian kernel to convolve the image and find border points.  If the given point is in the border points and is in the background of the image, it is added to the colony and the convolution image is updated.</p><p><strong>Arguments</strong></p><ul><li><code>img::AbstractArray</code>: The input image.</li><li><code>cov_img::AbstractArray</code>: The convolution image.</li><li><code>point::Vector{Int}</code>: The point at which to expand the colony.</li></ul><p><strong>Returns</strong></p><ul><li>The updated convolution image.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/artifical_colony_creation.jl#L213-L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.expand_colony_radom!-Tuple{AbstractArray, Int64}" href="#ColonyImages.expand_colony_radom!-Tuple{AbstractArray, Int64}"><code>ColonyImages.expand_colony_radom!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expand_colony_radom!(img::AbstractArray, pixels_to_add::Int)</code></pre><p>This function expands a colony in a random pattern within an image. The expansion is performed by adding pixels to the border of the colony.  The function directly modifies the input image. </p><p><strong>Arguments</strong></p><ul><li><code>img::AbstractArray</code>: The input image where the colony will be expanded.</li><li><code>pixels_to_add::Int</code>: The number of pixels to add to the colony.</li></ul><p>Compared to <code>expand_colony_radom_cov!</code>, this function is slower for large images and many pixels to add,  but faster for small images and and fewer pixels to add .This is due to the fact that the computational heavy convolution only needs to be      calculated once for the whole image, whereas the distance transform in <code>expand_colony_radom</code> needs to be calculated for each iteration of the loop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/artifical_colony_creation.jl#L251-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.expand_colony_radom_cov!-Tuple{AbstractArray, Int64}" href="#ColonyImages.expand_colony_radom_cov!-Tuple{AbstractArray, Int64}"><code>ColonyImages.expand_colony_radom_cov!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expand_colony_radom_cov!(img::AbstractArray, pixels_to_add::Int)</code></pre><p>Expand the colony in the image <code>img</code> by adding <code>pixels_to_add</code> pixels. The expansion is done randomly  at the border of the colony. The border is determined by convolving the image with a Laplacian kernel  and finding points where the convolution is greater than 0.1. The function modifies the input image in-place.</p><p>Compared to <code>expand_colony_radom!</code>, this function is faster for large images and many pixels to add,  but slower for small images and fewer pixels to add. This is due to the fact that the computationally heavy convolution only needs to be  calculated once for the whole image, whereas the distance transform in <code>expand_colony_radom</code> needs to be calculated for each iteration of the loop.</p><p><strong>Arguments</strong></p><ul><li><code>img::AbstractArray</code>: A 2D array representing the image of the colony. The colony is represented by 1s and the background by 0s.</li><li><code>pixels_to_add::Int</code>: The number of pixels to add to the colony.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">img = zeros(100, 100)
img[50:55, 50:55] .= 1
expand_colony_radom_cov!(img, 100)</code></pre><p>Compared to <code>expand_colony_radom!</code>, this function is faster for large images and many pixels to add,  but slower for small images and fewer pixels to add. This is due to the fact that the computational heavy convolution only needs to be      calculated once for the whole image, whereas the distance transform in <code>expand_colony_radom</code> needs to be calculated for each iteration of the loop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/artifical_colony_creation.jl#L88-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.expand_colony_radom_cov_show!-Tuple{AbstractArray, Int64}" href="#ColonyImages.expand_colony_radom_cov_show!-Tuple{AbstractArray, Int64}"><code>ColonyImages.expand_colony_radom_cov_show!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expand_colony_radom_cov_show!(img::AbstractArray, pixels_to_add::Int)</code></pre><p>Expand the colony in the image <code>img</code> by adding <code>pixels_to_add</code> pixels. The expansion is done randomly  at the border of the colony. The border is determined by convolving the image with a Laplacian kernel  and finding points where the convolution is greater than 0.1. The function modifies the input image in-place.</p><p>Compared to <code>expand_colony_radom!</code>, this function is faster for large images and many pixels to add,  but slower for small images and fewer pixels to add. This is due to the fact that the computationally heavy convolution only needs to be  calculated once for the whole image, whereas the distance transform in <code>expand_colony_radom</code> needs to be calculated for each iteration of the loop.</p><p><strong>Arguments</strong></p><ul><li><code>img::AbstractArray</code>: A 2D array representing the image of the colony. The colony is represented by 1s and the background by 0s.</li><li><code>pixels_to_add::Int</code>: The number of pixels to add to the colony.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">img = zeros(100, 100)
img[50:55, 50:55] .= 1
expand_colony_radom_cov!(img, 100)</code></pre><p>Compared to <code>expand_colony_radom!</code>, this function is faster for large images and many pixels to add,  but slower for small images and fewer pixels to add. This is due to the fact that the computational heavy convolution only needs to be      calculated once for the whole image, whereas the distance transform in <code>expand_colony_radom</code> needs to be calculated for each iteration of the loop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/artifical_colony_creation.jl#L150-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.expand_colony_un_radom_cov!-Tuple{AbstractArray, Int64, Vector{Int64}}" href="#ColonyImages.expand_colony_un_radom_cov!-Tuple{AbstractArray, Int64, Vector{Int64}}"><code>ColonyImages.expand_colony_un_radom_cov!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expand_colony_un_radom_cov!(img::AbstractArray, pixels_to_add::Int, dir::Vector{Int}; still_spawn_rate::AbstractFloat = 0.5)</code></pre><p>Expand the colony in the image <code>img</code> by adding <code>pixels_to_add</code> pixels. The expansion is done randomly  at the border of the colony, but it is more likely to expand in the direction specified by <code>dir</code>.  The border is determined by convolving the image with a Laplacian kernel and finding points where the convolution  is greater than 0.1. The function modifies the input image in-place.</p><p><strong>Arguments</strong></p><ul><li><code>img::AbstractArray</code>: A 2D array representing the image of the colony. The colony is represented by 1s and the background by 0s.</li><li><code>pixels_to_add::Int</code>: The number of pixels to add to the colony.</li><li><code>dir::Vector{Int}</code>: A vector representing the preferred direction of expansion.</li><li><code>still_spawn_rate::AbstractFloat</code>: A float representing the probability of expanding in a direction opposite to <code>dir</code>. Default is 0.5.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">img = zeros(100, 100)
img[50:55, 50:55] .= 1
expand_colony_un_radom_cov!(img, 100, [1, 0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/artifical_colony_creation.jl#L369-L389">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.expand_matrix-Tuple{Union{BitMatrix, Matrix{&lt;:Real}}}" href="#ColonyImages.expand_matrix-Tuple{Union{BitMatrix, Matrix{&lt;:Real}}}"><code>ColonyImages.expand_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>expand_matrix(mat::Union{Matrix{&lt;:Real}, BitMatrix}; annuli::Int = 2 )</p><p>Expands a matrix by adding zero-filled columns to its outermost right column and rotating it 90 degrees counterclockwise. This process is repeated 4 times per annulus. The number of additional bands (annuli) added to the matrix is determined by the annuli parameter.</p><p>Arguments mat::Union{Matrix{&lt;:Real}, BitMatrix}: The input matrix. annuli::Int: The number of additional bands to be added to the matrix. Default is 2. Returns The expanded matrix. Examples</p><pre><code class="language-julia hljs">mat = [1 2; 3 4]
expand_matrix(mat, annuli = 1)
4×4 Matrix{Int64}:
 0  0  0  0
 0  1  2  0
 0  3  4  0
 0  0  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/image_functions.jl#L727-L748">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.fill_holes-Tuple{Any, Real}" href="#ColonyImages.fill_holes-Tuple{Any, Real}"><code>ColonyImages.fill_holes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fill_holes(img, size_holes::Real)</code></pre><p>Fills holes in a binary image. The size of the holes to be filled is determined by the <code>size_holes</code> parameter.</p><p><strong>Arguments</strong></p><ul><li>`img: The input binary image.</li><li><code>size_holes::Real</code>: The relative size of the holes to be filled. This is a fraction of the total number of pixels in the image.</li></ul><p><strong>Returns</strong></p><ul><li>A binary image with the holes filled.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/image_functions.jl#L323-L335">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.filter_fourier_alpha-Tuple{Vector{&lt;:Real}}" href="#ColonyImages.filter_fourier_alpha-Tuple{Vector{&lt;:Real}}"><code>ColonyImages.filter_fourier_alpha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter_fourier_alpha(vec; a = 5)</code></pre><p>Filters a vector by setting all elements after the <code>a</code>-th element to zero. This function is useful for filtering the results of a Fourier transform, where the elements of the vector represent the amplitudes of the frequencies, and the index of the element represents the frequency. By setting all elements after the <code>a</code>-th element to zero, we effectively remove all frequencies higher than <code>a</code>.</p><p><strong>Arguments</strong></p><ul><li><code>vec::Vector{&lt;:Real}</code>: The input vector.</li><li><code>a::Int</code>: The cutoff frequency. All frequencies higher than <code>a</code> are removed. Default is 5.</li></ul><p><strong>Returns</strong></p><ul><li>A new vector where all elements after the <code>a</code>-th element are zero.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/image_functions.jl#L567-L579">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.filter_fourier_beta-Tuple{Vector{&lt;:Real}}" href="#ColonyImages.filter_fourier_beta-Tuple{Vector{&lt;:Real}}"><code>ColonyImages.filter_fourier_beta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter_fourier_beta(vec::Vector{&lt;:Real}; b::AbstractFloat = 0.5)</code></pre><p>Filters a vector by setting all elements whose absolute value is less than or equal to <code>b</code> times the maximum absolute value of the elements to zero. This function is useful for filtering the results of a Fourier transform, where the elements of the vector represent the amplitudes of the frequencies. By setting all elements whose amplitude is less than or equal to <code>b</code> times the maximum amplitude to zero, we effectively remove all frequencies with low amplitudes.</p><p><strong>Arguments</strong></p><ul><li><code>vec::Vector{&lt;:Real}</code>: The input vector.</li><li><code>b::AbstractFloat</code>: The threshold for the amplitude. All frequencies with amplitudes less than or equal to <code>b</code> times the maximum amplitude are removed. Default is 0.5.</li></ul><p><strong>Returns</strong></p><ul><li>A new vector where all elements whose absolute value is less than or equal to <code>b</code> times the maximum absolute value are zero.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/image_functions.jl#L598-L610">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.find_freq-Tuple{Vector{&lt;:Real}}" href="#ColonyImages.find_freq-Tuple{Vector{&lt;:Real}}"><code>ColonyImages.find_freq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_freq(vec::Vector{&lt;:Real}; ignore_latter_half = true )</code></pre><p>Finds the frequencies in a vector that have non-zero amplitudes. This function is useful for analyzing the results of a Fourier transform, where the elements of the vector represent the amplitudes of the frequencies, and the index of the element represents the frequency.</p><p><strong>Arguments</strong></p><ul><li><code>vec::Vector{&lt;:Real}</code>: The input vector.</li><li><code>ignore_latter_half::Bool</code>: If true, the function only considers the first half of the vector. This is useful when the input vector is the result of a Fourier transform, where the second half of the vector contains the same information as the first half but in reverse order. Default is true.</li></ul><p><strong>Returns</strong></p><ul><li>A vector of the frequencies that have non-zero amplitudes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/image_functions.jl#L633-L645">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.find_peaks-Tuple{Vector{&lt;:Real}}" href="#ColonyImages.find_peaks-Tuple{Vector{&lt;:Real}}"><code>ColonyImages.find_peaks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_peaks(signal::Vector{&lt;:Real}; threshold::AbstractFloat = 1.0)</code></pre><p>Finds the local maxima inside a 1D signal, in areas where the signal exceeds its mean value by a given factor. </p><p><strong>Arguments</strong></p><ul><li><code>signal::Vector{&lt;:Real}</code>: The input 1D signal.</li><li><code>threshold::AbstractFloat</code>: The factor by which the signal needs to exceed its mean value to be considered a peak. Default is 1.0.</li></ul><p><strong>Returns</strong></p><ul><li><code>position_peaks</code>: A vector of the positions of the peaks in the signal.</li><li><code>nr_peaks</code>: The number of peaks found in the signal.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/image_functions.jl#L672-L685">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.generate_dir_vec-Tuple{parameters}" href="#ColonyImages.generate_dir_vec-Tuple{parameters}"><code>ColonyImages.generate_dir_vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_dir_vec(para::parameters)</code></pre><p>Generates vectors of x and y coordinates that span vectors ranging from 0 to 2π.  This function is used to generate the vectors used in <code>expand_colony_finger_radom_cov!</code>.</p><p><strong>Arguments</strong></p><ul><li><code>para::parameters</code>: A parameters object containing various parameters for the analysis. <ul><li><code>number_finger</code>: The number of vectors to generate.</li><li><code>finger_dist</code>: The random distance to add to the vectors.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>dir::Array{Array{Float64,1},1}</code>: A vector of vectors, each containing the y and x coordinates of a vector.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using CairoMakie
para = parameters(number_finger = 20, finger_dist = 0.1)
dir = generate_dir_vec(para)
yy = zeros(para.number_finger)
arrows(yy,yy, [d[1] for d in dir], [d[2] for d in dir])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/artifical_colony_creation.jl#L426-L448">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.lattice_points-Tuple{Int64}" href="#ColonyImages.lattice_points-Tuple{Int64}"><code>ColonyImages.lattice_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice_points(r::Int)</code></pre><p>Generates a lattice of points within a circle of radius <code>r</code>.</p><p>The function returns a nested vector of points, each represented by its x and y coordinates.  The points are sorted by their distance from the origin and grouped into bands,  each band containing points that have a similar distance to the origin.</p><p><strong>Arguments</strong></p><ul><li><code>r::Int</code>: The radius of the circle within which the lattice points are generated.</li></ul><p><strong>Returns</strong></p><ul><li><code>points3::Vector{Vector{Vector{Int}}}</code>: A nested vector of points.</li></ul><p><code>points3</code> is a vector of vectors of <code>Lattice vectors</code> in ascending order by their length . Whereas the first entry of <code>Points</code> contains a vector of all lattice vectors which lengths are lower than 2:</p><pre><code class="language-julia hljs">Points[1] = [[0, 1], [0, 1], [0, -1], [0, -1], [1, 0], [-1, 0], [1, 0], [-1, 0], [1, 1], [-1, 1], [1, -1], [-1, -1]]</code></pre><p><code>Points[2]</code> does the same for length lower than 3:</p><pre><code class="language-julia hljs">Points[2] = [[0, 2], [0, 2], [0, -2], [0, -2], [2, 0], [-2, 0], [2, 0], [-2, 0], [1, 2], [-1, 2], [1, -2], [-1, -2], [2, 1], [-2, 1], [2, -1], [-2, -1], [2, 2], [-2, 2], [2, -2], [-2, -2]]</code></pre><p>and so on...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/image_functions.jl#L42-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.occupied_points-Tuple{Union{BitMatrix, Matrix{&lt;:Real}}}" href="#ColonyImages.occupied_points-Tuple{Union{BitMatrix, Matrix{&lt;:Real}}}"><code>ColonyImages.occupied_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">occupied_points(img::Union{Matrix{&lt;:Real}, BitMatrix})</code></pre><p>Calculates the proportion of occupied points in a given binary image <code>img</code>.</p><p>The function sums up all the pixel values in the image and divides by the total number of pixels.  This gives the proportion of occupied points, assuming that non-zero pixel values represent occupied points.</p><p><strong>Arguments</strong></p><ul><li><code>img::Union{Matrix{&lt;:Real}, BitMatrix}</code>: A 2D array representing the image. Non-zero values are considered as occupied points.</li></ul><p><strong>Returns</strong></p><ul><li>A float representing the proportion of occupied points in the image.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/image_functions.jl#L107-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.pair_cor_metric3-Tuple{Union{BitMatrix, Matrix{&lt;:Real}}, Vector{Int64}}" href="#ColonyImages.pair_cor_metric3-Tuple{Union{BitMatrix, Matrix{&lt;:Real}}, Vector{Int64}}"><code>ColonyImages.pair_cor_metric3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pair_cor_metric3(img::Union{Matrix{&lt;:Real}, BitMatrix}, center::Vector{Int}; samples::Int = 10000, steps::Int = 360)</code></pre><p>Calculates a pair correlation metric for a given image. The metric is a vector where each element represents the number of pairs of pixels that have a certain relative angle.  The angles are determined by dividing a half-circle into a certain number of equal parts.</p><p><strong>Arguments</strong></p><ul><li><code>img::Union{Matrix{&lt;:Real}, BitMatrix}</code>: The input image.</li><li><code>center::Vector{Int}</code>: The reference point for calculating the relative angles.</li><li><code>samples::Int</code>: The number of pairs of pixels to sample. Default is 10000.</li><li><code>steps::Int</code>: The number of sectors into which the half-circle is divided. Default is 360.</li></ul><p><strong>Returns</strong></p><ul><li>A vector where each element represents the number of pairs of pixels that have a certain relative angle.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/image_functions.jl#L500-L515">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.plot_and_save_time_series_metrics!-Tuple{AbstractArray, parameters, DataFrames.DataFrame}" href="#ColonyImages.plot_and_save_time_series_metrics!-Tuple{AbstractArray, parameters, DataFrames.DataFrame}"><code>ColonyImages.plot_and_save_time_series_metrics!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_and_save_time_series_metrics!(img_vec::AbstractArray, para::parameters, df::DataFrame; name_data =&quot;random_growth&quot;)</code></pre><p>This function creates a series of plots for each image in a stack, showing the original image, the angular metric, and the pair correlation metric. It also updates a DataFrame with the metrics.</p><p><strong>Arguments</strong></p><ul><li><code>img_vec::AbstractArray</code>: A 4D array where the first two dimensions are the image dimensions, the third dimension is the time point, and the fourth dimension is the image stack.</li><li><code>para::parameters</code>: A parameters object containing various parameters for the analysis. <ul><li><code>plot_factor</code>: The scaling factor for the plot size.</li><li><code>kernel_ratio::Float64</code>: The ratio for the kernel operation.</li><li><code>threshold_conv</code>: The threshold for the convolution operation.</li><li><code>steps_angular</code>: The number of steps for the angular metric calculation.</li><li><code>samples_pair</code>: The number of samples for the pair correlation metric calculation.</li><li><code>Points</code>: The number of points for the circle fitting.</li><li><code>threshold_c</code>: The threshold for the circle fitting.</li><li><code>colonies</code>: The names of the colonies.</li></ul></li><li><code>df::DataFrame</code>: A DataFrame to update with the metrics.</li><li><code>name_data::String</code>: A string to prepend to the date for the data set name in the DataFrame. Default is &quot;random_growth&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>fig_big::Figure</code>: A Figure object containing the plots.</li></ul><p><strong>Details</strong></p><p>The function first creates a Figure object with a size determined by the <code>res_scaling</code> function. It then loops over each image stack in <code>img_vec</code>. For each stack, it calculates the centroid of the first image and creates a kernel based on the approximate radius of the colony in the image.</p><p>The function then loops over each time point in the image stack. For each time point, it calculates the centroid of the convoluted image and calculates the angular metric and pair correlation metric for the original image and the image minus the first image in the stack.</p><p>The function then fits a circle to the image and calculates the angular metric and pair correlation metric for the image minus the fitted circle.</p><p>The function then creates three Axis objects for the original image, the angular metric, and the pair correlation metric, and adds plots to each axis. If the time point is not the first, it also plots the angular metric and pair correlation metric for the image minus the fitted circle.</p><p>Finally, the function increments a counter, updates the DataFrame with the metrics, and returns the Figure object after looping over all image stacks and time points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/plotting.jl#L172-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.plot_convolution_schematic2-Tuple{AbstractArray, AbstractArray, parameters}" href="#ColonyImages.plot_convolution_schematic2-Tuple{AbstractArray, AbstractArray, parameters}"><code>ColonyImages.plot_convolution_schematic2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_convolution_schematic2(colony::AbstractArray, colony_cov::AbstractArray, para::parameters; name = &quot;cov_fig1&quot;)</code></pre><p>This function creates a plot of a colony image and its convolution. </p><p><strong>Arguments</strong></p><ul><li><code>colony::AbstractArray</code>: A 3D array representing the colony image stack or a 2D array representing a single colony image.</li><li><code>colony_cov::AbstractArray</code>: A 3D array representing the convoluted colony image stack or a 2D array representing a single convoluted colony image.</li><li><code>para::parameters</code>: A parameters object containing various parameters for the analysis.</li><li><code>name::String</code>: An optional name for the output plot. Default is &quot;cov_fig1&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>cov_fig::Figure</code>: A Figure object containing the plots.</li></ul><p><strong>Details</strong></p><p>The function first determines the type of the <code>colony</code> and <code>colony_cov</code> inputs and extracts the data for the last time point if they are 3D arrays. </p><p>It then creates a Figure object and two Axis objects for the original colony and the convoluted colony. It adds heatmaps to each of these axes using the respective data.</p><p>The function then iterates over each point in the images and adds a text object to each point in the heatmaps, displaying the value at that point.</p><p>Finally, the function saves the figure as a PNG image and returns the Figure object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/plotting.jl#L365-L387">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.plot_convolution_schematic3-Tuple{AbstractArray, AbstractArray, parameters}" href="#ColonyImages.plot_convolution_schematic3-Tuple{AbstractArray, AbstractArray, parameters}"><code>ColonyImages.plot_convolution_schematic3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_convolution_schematic3(colony, colony_cov, para; name = &quot;cov_fig_kernel&quot;)</code></pre><p>This function creates a schematic plot of a convolution operation on a colony image. </p><p><strong>Arguments</strong></p><ul><li><code>colony::Array</code>: A 3D array representing the colony image stack.</li><li><code>colony_cov::Array</code>: A 3D array representing the convoluted colony image stack.</li><li><code>para::parameters</code>: A parameters object containing various parameters for the analysis.</li><li><code>name::String</code>: An optional name for the output plot. Default is &quot;cov<em>fig</em>kernel&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>cov_fig_k::Figure</code>: A Figure object containing the plots.</li></ul><p><strong>Details</strong></p><p>The function first sets up a theme for the plot with a specific font size. It then extracts the data for the last time point from the colony and convoluted images. It creates a kernel and places it in a larger matrix of zeros.</p><p>The function then creates a Figure object and three Axis objects for the original colony, the kernel, and the convoluted colony. It adds heatmaps to each of these axes using the respective data.</p><p>The function then iterates over each point in the images and adds a text object to each point in the heatmaps, displaying the value at that point.</p><p>Finally, the function saves the figure as a PNG image and returns the Figure object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/plotting.jl#L301-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.plot_metric_schematic-Tuple{AbstractArray, parameters, Any}" href="#ColonyImages.plot_metric_schematic-Tuple{AbstractArray, parameters, Any}"><code>ColonyImages.plot_metric_schematic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_metric_schematic(colony::AbstractArray, para::parameters, colormap ; name = &quot;metric_fig1&quot;)</code></pre><p>This function creates a schematic plot of a colony image and how it is cut into angle section to be analysed later. </p><p><strong>Arguments</strong></p><ul><li><code>colony::AbstractArray</code>: A  3D array representing the colony image stack.</li><li><code>para::parameters</code>: A parameters object containing various parameters for the analysis.</li><li><code>colormap</code>: A colormap to use for the heatmap.</li><li><code>name::String</code>: An optional name for the output plot. Default is &quot;metric_fig1&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>fig::Figure</code>: A Figure object containing the plots.</li></ul><p><strong>Details</strong></p><p>The function first creates a Figure object and extracts the first and last images from the colony stack. It creates a kernel based on the approximate radius of the colony and the kernel ratio parameter.</p><p>The function then cuts a portion of the last image and rotates it 90 degrees. It creates two Axis objects on the Figure and hides their decorations.</p><p>The function then cuts a portion of the first image and rotates it 90 degrees. It adds a heatmap to the first Axis, showing the difference between the last and first images.</p><p>The function then creates a pie chart on the second Axis, with each slice having an equal value, representing the angle sections of the colony.</p><p>Finally, the function returns the Figure object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/plotting.jl#L426-L450">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.plot_time_series_cov_centroid-Tuple{AbstractArray, parameters}" href="#ColonyImages.plot_time_series_cov_centroid-Tuple{AbstractArray, parameters}"><code>ColonyImages.plot_time_series_cov_centroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_time_series_cov_centroid(img_vec::AbstractArray, para::parameters)</code></pre><p>Generates a time series plot of the centroids of the images in <code>img_vec</code>. The centroids are calculated in three ways: </p><ol><li>The original centroid of the first timestep of the timeseries.</li><li>The centroid after applying a convolution operation.</li><li>The current centroid of the image.</li></ol><p><strong>Arguments</strong></p><ul><li><code>img_vec::AbstractArray</code>: A vector of 3D image stacks.</li><li><code>para::parameters</code>: A parameters object containing various parameters for the analysis. <ul><li><code>kernel_ratio::Float64</code>: The ratio for the kernel operation. Default is <code>0.4</code>.</li><li><code>plot_factor</code>: The scaling factor for the plot size.</li><li><code>threshold_conv</code>: The threshold for the convolution operation.</li><li><code>colonies</code>: The names of the colonies.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>fig_big::Figure</code>: A Figure object with the time series plot of the centroids.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">img_vec = [rand(100, 100, 10) for _ in 1:5]
para = parameters(kernel_ratio = 0.4, plot_factor = 1, threshold_conv = 0.5, colonies = [&quot;Colony i&quot; for i in 1:5])
fig = plot_time_series_cov_centroid(img_vec, para)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/plotting.jl#L38-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.plot_time_series_metrics-Tuple{AbstractArray, parameters}" href="#ColonyImages.plot_time_series_metrics-Tuple{AbstractArray, parameters}"><code>ColonyImages.plot_time_series_metrics</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_time_series_metrics(img_vec, para)</code></pre><p>This function creates a series of plots for each image in a stack, showing the original image, the angular metric, and the pair correlation metric. </p><p><strong>Arguments</strong></p><ul><li><code>img_vec::Array</code>: A 4D array where the first two dimensions are the image dimensions, the third dimension is the time point, and the fourth dimension is the image stack.</li><li><code>para::parameters</code>: A parameters object containing various parameters for the analysis.</li></ul><p><strong>Returns</strong></p><ul><li><code>fig_big::Figure</code>: A Figure object containing the plots.</li></ul><p><strong>Details</strong></p><p>The function first creates a Figure object with a size determined by the <code>res_scaling</code> function. It then loops over each image stack in <code>img_vec</code>. For each stack, it calculates the centroid of the first image and creates a kernel based on the approximate radius of the colony in the image.</p><p>The function then loops over each time point in the image stack. For each time point, it calculates the centroid of the convoluted image and calculates the angular metric and pair correlation metric for the original image and the image minus the first image in the stack.</p><p>The function then fits a circle to the image and calculates the angular metric and pair correlation metric for the image minus the fitted circle.</p><p>The function then creates three Axis objects for the original image, the angular metric, and the pair correlation metric, and adds plots to each axis. If the time point is not the first, it also plots the angular metric and pair correlation metric for the image minus the fitted circle.</p><p>Finally, the function increments a counter and returns the Figure object after looping over all image stacks and time points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/plotting.jl#L97-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.plot_timeseries_heatmap-Tuple{AbstractArray, parameters}" href="#ColonyImages.plot_timeseries_heatmap-Tuple{AbstractArray, parameters}"><code>ColonyImages.plot_timeseries_heatmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_timeseries_heatmap(colony::AbstractArray, para::parameters; name = &quot;Eden Growth Model&quot;, colormap  = reverse(co.Blues))</code></pre><p>This function creates a heatmap plot of a colony image stack over time.</p><p><strong>Arguments</strong></p><ul><li><code>colony::AbstractArray</code>: A 3D array representing the colony image stack.</li><li><code>para::parameters</code>: A parameters object containing various parameters for the analysis.</li><li><code>name::String</code>: An optional name for the output plot. Default is &quot;Eden Growth Model&quot;.</li><li><code>colormap</code>: An optional colormap to use for the heatmap. Default is the reverse of Blues.</li></ul><p><strong>Returns</strong></p><ul><li><code>fig_eden::Figure</code>: A Figure object containing the heatmap plot.</li></ul><p><strong>Details</strong></p><p>The function first creates a Figure object and an Axis object with the title set to the provided name. It then initializes an intensity image with zeros.</p><p>The function then iterates over the z-dimension of the colony stack, adding each image to the intensity image.</p><p>It then creates a heatmap on the Axis, showing the intensity image with the maximum intensity subtracted and the sign reversed.</p><p>The function then hides the decorations of the Axis and adds a colorbar to the Figure, with the ticks set to the time points and the label set to &quot;time [h]&quot;.</p><p>Finally, the function saves the Figure as a PDF in the plots folder and returns the Figure object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/plotting.jl#L482-L506">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.rad2deg_discrete-Tuple{AbstractFloat}" href="#ColonyImages.rad2deg_discrete-Tuple{AbstractFloat}"><code>ColonyImages.rad2deg_discrete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rad2deg_discrete(ϕ::AbstractFloat; steps::Int =360)</code></pre><p>Converts an angle in radians to a discrete angle in degrees. The output is the number of a circular sector on a unit circle divided into a given number of sectors.  For example, if the angle is 0.0 and the number of steps is 360, the output is 1, which corresponds to the first circular sector on the unit circle.  If the angle is (2pi - 0.01) and the number of steps is 360, the output is 360, which corresponds to the last circular sector on the unit circle.</p><p><strong>Arguments</strong></p><ul><li><code>ϕ::AbstractFloat</code>: The input angle in radians.</li><li><code>steps::Int</code>: The number of circular sectors into which the unit circle is divided. Default is 360.</li></ul><p><strong>Returns</strong></p><ul><li>The number of the circular sector to which the angle corresponds.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/image_functions.jl#L345-L359">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.res_scaling-Tuple{AbstractArray}" href="#ColonyImages.res_scaling-Tuple{AbstractArray}"><code>ColonyImages.res_scaling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">res_scaling(img_int_vec; factor = 3, plots = 1)</code></pre><p>Scales the resolution of a plot based on a given factor. The function counts the number of images in the given image_vec and and scales the resolution  of plot containg all these images accordingly.</p><p><strong>Arguments</strong></p><ul><li><code>img_int_vec</code>: A vector of images.</li><li><code>factor</code>: The scaling factor. Defaults to 3.</li><li><code>plots</code>: The number of plots per images. Defaults to 1.</li></ul><p><strong>Returns</strong></p><ul><li>A tuple containing the scaled width and height of the image.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/plotting.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.save_time_series_metrics!-Tuple{AbstractArray, parameters, DataFrames.DataFrame}" href="#ColonyImages.save_time_series_metrics!-Tuple{AbstractArray, parameters, DataFrames.DataFrame}"><code>ColonyImages.save_time_series_metrics!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">save_time_series_metrics!(img_vec::AbstractArray, para::parameters, df::DataFrame; name_data=&quot;random_growth&quot;)</code></pre><p>This function calculates and saves time series metrics for a given set of images.</p><p><strong>Arguments</strong></p><ul><li><code>img_vec::AbstractArray</code>: An array of image stacks.</li><li><code>para::parameters</code>: An object containing various parameters for the analysis.</li><li><code>df::DataFrame</code>: The DataFrame to which the calculated metrics will be appended.</li><li><code>name_data::String</code>: (optional) A string representing the name of the data set. Default is &quot;random_growth&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>data_set::String</code>: The name of the data set.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/plotting.jl#L260-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ColonyImages.@h-Tuple{Any}" href="#ColonyImages.@h-Tuple{Any}"><code>ColonyImages.@h</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@h methodname</p><p>Outputs documentations in jupyternotenbooks in VScode as markdown without bugs.</p><p>Example of how to use the <code>@h</code> macro:</p><pre><code class="language-julia hljs">@h res_scaling(img_int_vec; factor = 3, plots = 1)</code></pre><p>Outputs documentations in jupyternotenbooks in VScode as markdown without bugs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/ColonyImages.jl/blob/2ac08de36daaa29729bc381d099bc35ce65dd6f0/src/plotting.jl#L529-L540">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Monday 25 March 2024 16:06">Monday 25 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
