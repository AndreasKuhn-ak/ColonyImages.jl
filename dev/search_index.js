var documenterSearchIndex = {"docs":
[{"location":"#ColonyImages","page":"Home","title":"ColonyImages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ColonyImages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"    Modules = [ColonyImages]","category":"page"},{"location":"#ColonyImages.approx_radi_colo-Tuple{Any}","page":"Home","title":"ColonyImages.approx_radi_colo","text":"approx_radi_colo(img)\n\nCalculates the approximate diameter of a colony by summing up all the pixel values and taking the square root of the sum.\n\nThis function assumes that the pixel values represent the area of the colony. The diameter is then approximated using the formula for the diameter of a circle given its area.\n\nArguments\n\nimg: A 2D array representing the image. The pixel values are assumed to represent the area of the colony.\n\nReturns\n\nA float representing the approximate diameter of the colony.\n\n\n\n\n\n","category":"method"},{"location":"#ColonyImages.b_w-Tuple{Any}","page":"Home","title":"ColonyImages.b_w","text":"Converts an grayscale colony image into a binary image/BitArray. Checks if more than half of image is black and inverts it in that case As the colony is always much smaller that the background, this ensures that in the output image the pixels inside the colony are always set to 1 and the background pixels to 0, no matter the invertion status of the input image . \n\n\n\n\n\n","category":"method"},{"location":"#ColonyImages.build_circle-Tuple{Vector{Int64}, Any, Vector{Vector{Vector{Int64}}}}","page":"Home","title":"ColonyImages.build_circle","text":"build_circle(center::Vector{Int}, img, points::Vector{Vector{Vector{Int}}}; threshold = 0.8::Float64)\n\nCreates a binary image with the same size as the input image. The binary image is a circle with a given center.  The circle is built by iterating over a set of points and setting the corresponding pixel in the binary image to 1 if the point is within the circle. The occupation in the outermost circle band is calculated in each iteration and stored in the occupation vector.  The function stops building the circle when the mean of the occupation vector is less than a given threshold.\n\nArguments\n\ncenter::Vector{Int}: The center of the circle.\nimg: The input image.\npoints::Vector{Vector{Vector{Int}}}: A set of points used to build the circle.\nthreshold::Float64: The threshold for the mean of the occupation vector. Defaults to 0.8.\n\nReturns\n\ncircle_kernel: A binary image representing the circle.\n\n\n\n\n\n","category":"method"},{"location":"#ColonyImages.centroid-Tuple{Any}","page":"Home","title":"ColonyImages.centroid","text":"centroid(img)\n\nCalculates the centroid of a given image img.\n\nThe centroid is calculated as the average of the x and y coordinates of all non-zero pixels in the image,  weighted by their intensity. The coordinates are then rounded to the nearest integer.\n\nArguments\n\nimg: A 2D array representing the image. Non-zero values are considered as part of the object to find the centroid of.\n\nReturns\n\ncentroid_norm::Vector{Int64}: A vector containing the x and y coordinates of the centroid.\n\n\n\n\n\n","category":"method"},{"location":"#ColonyImages.conv-Tuple{Any, Any}","page":"Home","title":"ColonyImages.conv","text":"Creates a Convolution of an Image with a given kernel. The input image is a 2D Int or Float array.  The kernel is a smaller 2D Int or Float array. The output is a 2D FLoat64 array with the same size the input image. \n\n\n\n\n\n","category":"method"},{"location":"#ColonyImages.create_kernel-Tuple{Int64}","page":"Home","title":"ColonyImages.create_kernel","text":"create_kernel(rad::Int;  geometry::String = \"circle\")\n\nCreates a binary image kernel with a given radius. The kernel can be either a circle or a square.\n\nArguments\n\nrad::Int: The radius of the kernel.\ngeometry::String: The shape of the kernel. Can be either \"circle\" or \"square\". Defaults to \"circle\".\n\nReturns\n\nkernel: A 2D array representing the kernel.\n\n\n\n\n\n","category":"method"},{"location":"#ColonyImages.expand_colony_fractal_radom_cov!-Tuple{Any, Any}","page":"Home","title":"ColonyImages.expand_colony_fractal_radom_cov!","text":"Expands colony randomly but it is more likely to expand to points that only have 2 neigboors or less\n\n\n\n\n\n","category":"method"},{"location":"#ColonyImages.fill_holes-Tuple{Any, Any}","page":"Home","title":"ColonyImages.fill_holes","text":"Filles holes in \n\n\n\n\n\n","category":"method"},{"location":"#ColonyImages.find_peaks-Tuple{Any}","page":"Home","title":"ColonyImages.find_peaks","text":"Finds the local maxima inside a 1D signal, in areas where the  signal exceed an its mean value by a given factor\n\n\n\n\n\n","category":"method"},{"location":"#ColonyImages.generate_dir_vec-Tuple{Any, Any}","page":"Home","title":"ColonyImages.generate_dir_vec","text":"generate_dir_vec(number_fingers, rand_dist)\n\nGenerates vectors of x and y coordinates that span vectors ranging from 0 to 2Ï€.\n\nArguments\n\nnumber_fingers: The number of vectors to generate.\nrand_dist: The random distance to add to the vectors.\n\nReturns\n\ndir: A vector of vectors, each containing the y and x coordinates of a vector.\n\nExample\n\nusing CairoMakie\nnumber_vecs = 20\ny,x = generate_dir_vec(20,0.1)\nyy = zeros(number_vecs)\narrows(yy,yy, y, x)\n\n\n\n\n\n","category":"method"},{"location":"#ColonyImages.lattice_points-Tuple{Int64}","page":"Home","title":"ColonyImages.lattice_points","text":"lattice_points(r::Int)\n\nGenerates a lattice of points within a circle of radius r.\n\nThe function returns a nested vector of points, each represented by its x and y coordinates.  The points are sorted by their distance from the origin and grouped into bands,  each band containing points that have a similar distance to the origin.\n\nArguments\n\nr::Int: The radius of the circle within which the lattice points are generated.\n\nReturns\n\npoints3::Vector{Vector{Vector{Int}}}: A nested vector of points.\n\npoints3 is a vector of vectors of Lattice vectors in ascending order by their length . Whereas the first entry of Points contains a vector of all lattice vectors which lengths are lower than 2:\n\nPoints[1] = [[0, 1], [0, 1], [0, -1], [0, -1], [1, 0], [-1, 0], [1, 0], [-1, 0], [1, 1], [-1, 1], [1, -1], [-1, -1]]\n\nPoints[2] does the same for length lower than 3:\n\nPoints[2] = [[0, 2], [0, 2], [0, -2], [0, -2], [2, 0], [-2, 0], [2, 0], [-2, 0], [1, 2], [-1, 2], [1, -2], [-1, -2], [2, 1], [-2, 1], [2, -1], [-2, -1], [2, 2], [-2, 2], [2, -2], [-2, -2]]\n\nand so on...\n\n\n\n\n\n","category":"method"},{"location":"#ColonyImages.occupied_points-Tuple{Any}","page":"Home","title":"ColonyImages.occupied_points","text":"occupied_points(img)\n\nCalculates the proportion of occupied points in a given binary image img.\n\nThe function sums up all the pixel values in the image and divides by the total number of pixels.  This gives the proportion of occupied points, assuming that non-zero pixel values represent occupied points.\n\nArguments\n\nimg: A 2D array representing the image. Non-zero values are considered as occupied points.\n\nReturns\n\nA float representing the proportion of occupied points in the image.\n\n\n\n\n\n","category":"method"},{"location":"#ColonyImages.rad2deg_discrete-Tuple{Any}","page":"Home","title":"ColonyImages.rad2deg_discrete","text":"Helper functions for angular metric, takes an angle in radiants as input and a number of circular sectors into which a unit circle is divided. The output is the number of circular sector to which the angle corresponds. E.g angle = 0.0 ,steps = 360 ;output = 1 which is first circular sector on the unit circle, EG.  angle = (2pi -0.01), steps = 360, output = 360, last circular sector ranging from 2pi -0.01), steps = 360, output = 360, last circular sector ranging from [2pi/steps *(steps-1) - 2pi)\n\n\n\n\n\n","category":"method"},{"location":"#ColonyImages.res_scaling-Tuple{Any}","page":"Home","title":"ColonyImages.res_scaling","text":"res_scaling(img_int_vec; factor = 3, plots = 1)\n\nScales the resolution of a plot based on a given factor. The function counts the number of images in the given image_vec and and scales the resolution  of plot containg all these images accordingly.\n\nArguments\n\nimg_int_vec: A vector of images.\nfactor: The scaling factor. Defaults to 3.\nplots: The number of plots per images. Defaults to 1.\n\nReturns\n\nA tuple containing the scaled width and height of the image.\n\n\n\n\n\n","category":"method"}]
}
